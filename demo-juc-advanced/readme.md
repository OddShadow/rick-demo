# Java 并发进阶

## 1. CompletableFuture

### 常用 API

1. 获得结果和触发计算

   1. `completableFuture.get()`

      调用线程阻塞直到拿到返回值

   2. `completableFuture.get(2L, TimeUnit.SECONDS)`

      调用线程阻塞直到拿到返回值，如果超时抛出 `TimeoutException`

   3. `completableFuture.join()`

      调用线程阻塞直到拿到返回值，封装异常，不用手动处理

   4. `completableFuture.getNow("defaultValue")`

      立刻拿到返回值，如果任务没有完成则返回传参值

   5. `completableFuture.complete("defaultValue")`

      立刻拿到返回值，如果任务没有完成则中断任务，将参数作为最终结果

2. 对计算结果进行处理

   1. `thenApply(f -> f)` 

      线程的计算结果存在依赖关系，线程串行化执行，上一步抛出异常，当前步骤不执行并且终止线程操作

   2. `handle((f, e) -> f)`

      线程的计算结果存在依赖关系，线程串行化执行，并且可以即使上一步抛出异常，依然可以继续执行当前步骤

3. 对计算结构进行消费

4. 对计算速度进行选用

5. 对计算结果进行合并

## 2. Java 锁实现

### 乐观锁 和 悲观锁

- 悲观锁
  适合写多的场景，加锁保证资源在持有锁期间不会被其它线程修改 `synchronized` 和 `Lock` 都是悲观锁
- 乐观锁
  先查后更新，更新时检查数据是否在查出后被其它线程修改了，如果没有修改则更新成功，`version`机制，`CAS` 算法

### synchronized 的三种基本使用

1. 同步代码块 锁指定对象
2. 同步方法 锁 this 对象
3. 同步静态方法 锁 Class 类

> 翻阅 JDK 源码可知 ObjectMonitor.java -> ObjectMonitor.cpp -> objectMonitor.hpp
> 对于 Java 中每个对象都继承 Object 对象，所以都有 ObjectMonitor 对象，对象中有属性 _owner 指向持有该对象锁的线程

### 公平锁 和 非公平锁

- 公平锁
  多个线程按照申请锁的顺序来获取锁，由于频繁上下文切换线程开销会比非公平锁大
  `ReentrantLock lock = new ReentrantLock(true)`

- 非公平锁

  多个线程获取获得锁的顺序由系统分配，高并发环境下有可能导致 优先级翻转 或者 线程饥饿
  `ReentrantLock lock = new ReentrantLock()`

### 可重入锁

如果对已经上锁的普通互斥锁进行“加锁”操作，其结果要么失败，要么会阻塞至解锁。
而如果换作可重入互斥锁，当且仅当尝试加锁的线程就是持有该锁的线程时，类似的加锁操作就会成功。
可重入互斥锁一般都会记录被加锁的次数，只有执行相同次数的解锁操作才会真正解锁。
可重入解决了普通互斥锁不可重入的问题，如果函数先持有锁，然后执行回调，但回调的内容是调用它自己，就会产生死锁。
`synchronized` 和 `Lock` 都是可重入锁

> 翻阅 JDK 源码可知 ObjectMonitor 对象有一个 锁重入次数 _recursions 和 记录该线程获取锁的次数 _count 实现锁的重入

### 死锁

当两个以上的线程，双方都在等待对方停止执行，以取得系统资源，但是没有一方提前退出时，就称为死锁

死锁的四个原因

1. 禁止抢占 系统资源不能被强制从一个进程中退出
2. 持有和等待 一个进程可以在等待时持有系统资源
3. 互斥 资源只能同事分配给一个进程，无法多个进程公用
4. 循环等待 一系列进程互相持有其它进程所需要的资源

Java 排查死锁

1. 查看 java 进程`jps -l` 和 排查进程死锁 `jstack ***`
2. 视图 `jconsole`

## 3. LockSupport 和 线程中断

中断机制

一个线程不应该由其它线程【强制中断】或【停止】，而是应该由线程本身自行停止，所以 `Thread.stop()` `Thread.suspend()` `Thread.resume()` 已过时
Java 采取了【中断标识协商机制】
中断只是以一种协商机制，Java 没有增加任何中断语法，中断过程由程序员自己实现

## 6. Java 内存模型 - JMM - Java Memory Model

### 1. 面试题

- 什么是 Java 内存模型 JMM
- JMM 和 volatile 之间的关系
- JMM 有哪些特性，它的三大特性是什么
- 为什么需要 JMM，作用和功能是什么
- happens-before 先行发生原则你有了解过嘛

### 2. 计算机硬件存储体系回顾

硬盘 - 内存 - CPU三级缓存 - CPU二级缓存 - CPU一级缓存 - 寄存器
由于各级读写速度不一致，JVM 规范试图定义一种内存模型 JMM 来屏蔽各种硬件和操作系统的内存访问差异
实现 Java 程序在各个平台下都能达到一致的内存访问效果

### 3. JMM 模型

JMM 本身是一种抽象的概念，仅仅是描述一组规范或者约定，通过这组描述或者约定定义了程序-尤其是多线程-各个变量的读写访问方式并决定一个线程对共享变量的何时写入以及如何变成对另一个线程可见
JMM 的关键技术点主要讨论 多线程的 【原子性】【可见性】【有序性】

### 4. 原子性 可见性 有序性

#### 原子性

一个操作是不可打断的，多线程环境下，不会被其它线程影响

#### 可见性

当一个线程修改了某一个共享变量的值，其它线程能够立刻知道变更，JMM 规定了所有的变量都存储在【主内存中】

- 主内存【内存】【存储共享变量 A】 
  - 线程 1 工作内存【CPU缓存或者CPU自己的寄存器】【存储共享变量 A 副本1】
  - 线程 2 工作内存【CPU缓存或者CPU自己的寄存器】【存储共享变量 A 副本2】

线程 1 本地工作内存修改了变量 A 之后会提交回主内存，但是这个过程线程 2 不一定感知到，所以导致了共享变量 A 对线程 2 不可见，即脏读

#### 有序性

【源代码】- 【编译器优化重排】-【指令并行的重排】-【内存系统的重排】-【最终执行的指令】
为了提升性能，编译器和处理器可能会对指令序列进行重新排序，Java 规范规定 JVM 线程内维持顺序化语义，即只要程序的最终结果和它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，这个过程被程序指令的重排序

重点在于【指令重排可以保证串行语义一致，但是不保证多线程间语义也一致】
所以处理器在进行重排序时必须考虑指令间的数据依赖性

### 5. JMM 规范下，多线程对变量的读写过程

由于 JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而 Java 内存模型中规定所有变量都存储在主内存中，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变是副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。

### 6. JMM 规范下，多线程先行发生原则之 happens-before

#### 八条规则

1. 【程序顺序规则】如果程序中操作A在操作B之前，那么在线程中A操作将在B操作之前执行
2. 【监视器锁规则】在监视器锁上的解锁操作必须在同一个监视器锁上的加锁操作之前执行
3. 【volatile 变量规则】对 volatile 变量的写入操作必须在对该变量的读操作之前执行
4. 【线程启动规则】线程上对 Thread.start 的调用必须在对该线程中执行任何操作之前执行
5. 【线程结束规则】线程中的任何操作都必须在其它线程检测到该线程已经结束之前执行，或者从 Thread.join 中成功返回，或者在调用 Thread.isAlive 时返回 false
6. 【中断规则】当一个线程在另一个线程上调用 interrupt 时，必须在被中断线程检测到 interrupt 调用之前执行（通过抛出 InterruptedException，或者调用 isInterrupted 和 interrupted）
7. 【终结器规则】对象的构造函数必须在启动该对象的终结器之前执行完成
8. 【传递性】如果操作 A 在操作 B 之前执行，并且操作 B 在操作 C 之前执行，那么操作 A 必须在操作 C 之前执行

## 7. volatile 和 JMM

### 被 volatile 修饰的变量特点

- 特点

  - 可见性
  - 有序性 - 禁止指令重排序

- 内存语义

  - 写一个 volatile 变量，JMM 把该线程对应的本地内存中的共享变量值立刻刷新回主内存中
  - 读一个 volatile 变量，JMM 把该线程对应的本地内存设置为无效，重新回主内存中读取最新共享变量

- 【内存屏障】

  CPU 或者 编译器对内存随机访问操作中的一个同步点，此点之前的所有读写操作都执行之后才可以开始执行此点之后的操作，其实就是一种 JVM 指令，JMM 的重排规则会要求 Java 编译器在生产 JVM 指令时插入特定的内存屏障指令，以此保证可见性和有序性
  内存屏障之前的所有写操作都要回写主内存中
  内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果，即可见性
  【写屏障】【Store Memory Barrier】处理器在写屏障之前将所有存储在缓存(store bufferes)中的数据同步到主内存。也就是说当看到 Stor e屏障指令，就必须把该指令之前所有写入指令执行完毕才能继续往下执行。
  【读屏障】【Load Memory Barrier】处理器在读屏障之后的读操作，都在读屏障之后执行。也就是说在 Load 屏障指令之后就能够保证后面的读取数据指令一定能够读取到最新的数据。

- 四种屏障类型
  1. LoadLoad - `Load1;LoadLoad;Load2` - 保证 load1 的读取操作在 load2 以及后续读取操作之前执行
  2. StoreStore - `Store1;StoreStore;Store2` - 保证 store2 及其后的写操作执行前，保证 store1 的写操作已刷新到主内存中
  3. LoadStore - `Load1;LoadStore;Store2` - 保证 store2 及其后的写操作执行前，保证 load1 的读操作已读取结束
  4. StroeLoad - `Store1;StoreLoad;Load2` 保证 store1 的写操作已刷新到主内存之后，load2 及其后的读操作才能执行